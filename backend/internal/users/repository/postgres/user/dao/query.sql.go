// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: query.sql

package dao

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const countByEmail = `-- name: CountByEmail :one
SELECT COUNT(*)
FROM "user"
WHERE email = $1
`

func (q *Queries) CountByEmail(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRow(ctx, countByEmail, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteUser = `-- name: DeleteUser :one
DELETE
FROM "user"
WHERE user_id = $1
RETURNING user_id, name, email, password, created_at, modified_at, profile_image_url
`

func (q *Queries) DeleteUser(ctx context.Context, userID uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, deleteUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.ProfileImageUrl,
	)
	return i, err
}

const findByEmail = `-- name: FindByEmail :one
SELECT user_id, email, password
FROM "user"
WHERE email = $1
`

type FindByEmailRow struct {
	UserID   uuid.UUID
	Email    string
	Password string
}

func (q *Queries) FindByEmail(ctx context.Context, email string) (FindByEmailRow, error) {
	row := q.db.QueryRow(ctx, findByEmail, email)
	var i FindByEmailRow
	err := row.Scan(&i.UserID, &i.Email, &i.Password)
	return i, err
}

const findById = `-- name: FindById :one
SELECT user_id, email, password
FROM "user"
WHERE user_id = $1
`

type FindByIdRow struct {
	UserID   uuid.UUID
	Email    string
	Password string
}

func (q *Queries) FindById(ctx context.Context, userID uuid.UUID) (FindByIdRow, error) {
	row := q.db.QueryRow(ctx, findById, userID)
	var i FindByIdRow
	err := row.Scan(&i.UserID, &i.Email, &i.Password)
	return i, err
}

const getUserData = `-- name: GetUserData :one
SELECT user_id, email, name, profile_image_url
FROM "user"
WHERE user_id = $1
`

type GetUserDataRow struct {
	UserID          uuid.UUID
	Email           string
	Name            string
	ProfileImageUrl sql.NullString
}

func (q *Queries) GetUserData(ctx context.Context, userID uuid.UUID) (GetUserDataRow, error) {
	row := q.db.QueryRow(ctx, getUserData, userID)
	var i GetUserDataRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Name,
		&i.ProfileImageUrl,
	)
	return i, err
}

const insertCredential = `-- name: InsertCredential :one
INSERT INTO "user"(email, password, name)
VALUES ($1, $2, $3)
RETURNING user_id, email, password
`

type InsertCredentialParams struct {
	Email    string
	Password string
	Name     string
}

type InsertCredentialRow struct {
	UserID   uuid.UUID
	Email    string
	Password string
}

func (q *Queries) InsertCredential(ctx context.Context, arg InsertCredentialParams) (InsertCredentialRow, error) {
	row := q.db.QueryRow(ctx, insertCredential, arg.Email, arg.Password, arg.Name)
	var i InsertCredentialRow
	err := row.Scan(&i.UserID, &i.Email, &i.Password)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :one
UPDATE "user"
SET password    = $1,
    modified_at = now()
WHERE user_id = $2
RETURNING user_id, email, password
`

type UpdatePasswordParams struct {
	Password string
	UserID   uuid.UUID
}

type UpdatePasswordRow struct {
	UserID   uuid.UUID
	Email    string
	Password string
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) (UpdatePasswordRow, error) {
	row := q.db.QueryRow(ctx, updatePassword, arg.Password, arg.UserID)
	var i UpdatePasswordRow
	err := row.Scan(&i.UserID, &i.Email, &i.Password)
	return i, err
}

const updateUserData = `-- name: UpdateUserData :one
UPDATE "user"
SET name = $1,
    profile_image_url = $2,
    modified_at = now()
WHERE user_id = $3
RETURNING user_id, email, name, profile_image_url
`

type UpdateUserDataParams struct {
	Name            string
	ProfileImageUrl sql.NullString
	UserID          uuid.UUID
}

type UpdateUserDataRow struct {
	UserID          uuid.UUID
	Email           string
	Name            string
	ProfileImageUrl sql.NullString
}

func (q *Queries) UpdateUserData(ctx context.Context, arg UpdateUserDataParams) (UpdateUserDataRow, error) {
	row := q.db.QueryRow(ctx, updateUserData, arg.Name, arg.ProfileImageUrl, arg.UserID)
	var i UpdateUserDataRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Name,
		&i.ProfileImageUrl,
	)
	return i, err
}
